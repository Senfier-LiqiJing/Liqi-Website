{{/* Custom body end content - dynamic backgrounds */}}
{{/* Create page-bg div for all pages */}}
<div id="page-bg" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1;"></div>

<script>
  // Dynamic Background Configuration with Page Detection
  (function() {
    console.log('üöÄ Background script starting...');

    const pageBg = document.getElementById('page-bg');

    if (!pageBg) {
      console.warn('‚ùå page-bg element not found');
      return;
    }

    console.log('‚úÖ page-bg element found');

    // Detect current page type
    function getPageType() {
      const path = window.location.pathname;
      console.log('üîç Current path:', path);

      if (path === '/' || path === '/index.html') {
        return 'home';
      } else if (path.includes('/projects') || path.includes('/project/') || path.includes('/blog/')) {
        return 'projects';
      } else if (path.includes('/topics') || path.includes('/topic/')) {
        return 'topics';
      } else if (path.includes('/education')) {
        return 'education';
      }

      return 'default';
    }

    const pageType = getPageType();
    console.log(`üìÑ Page type detected: ${pageType}`);

    // Configuration based on page type
    let backgroundConfig;

    switch(pageType) {
      case 'home':
        backgroundConfig = {
          type: 'gradient',
          gradientVariant: 'sunset',
          useOverlay: false
        };
        break;

      case 'projects':
        backgroundConfig = {
          type: 'gradient',
          gradientVariant: 'ocean',
          useOverlay: false
        };
        break;

      case 'topics':
        backgroundConfig = {
          type: 'gradient',
          gradientVariant: 'ocean',
          useOverlay: false
        };
        break;

      case 'education':
        backgroundConfig = {
          type: 'gradient',
          gradientVariant: 'ocean',
          useOverlay: false
        };
        break;

      default:
        backgroundConfig = {
          type: 'gradient',
          gradientVariant: 'professional',
          useOverlay: false
        };
    }

    console.log(`üé® Applying background: ${backgroundConfig.type} - ${backgroundConfig.gradientVariant}`);

    // Apply background based on type
    switch(backgroundConfig.type) {
      case 'gradient':
        pageBg.className = `bg-animated-gradient ${backgroundConfig.gradientVariant}`;
        break;

      case 'geometric':
        pageBg.className = 'bg-geometric';
        // Add dark mode class if needed
        if (document.body.classList.contains('dark')) {
          pageBg.classList.add('dark-mode');
        }
        break;

      case 'mesh':
        pageBg.className = 'bg-mesh-gradient';
        if (document.body.classList.contains('dark')) {
          pageBg.classList.add('dark-mode');
        }
        break;

      case 'particle':
        // Set data attributes for particle background
        pageBg.dataset.particleBackground = 'true';
        pageBg.dataset.particleCount = 80;
        pageBg.dataset.particleSpeed = 0.5;
        pageBg.dataset.lineDistance = 150;
        pageBg.dataset.interactive = true;
        break;

      case 'waves':
        pageBg.className = 'bg-waves';
        // Add wave elements
        for (let i = 0; i < 3; i++) {
          const wave = document.createElement('div');
          wave.className = 'wave';
          pageBg.appendChild(wave);
        }
        break;

      case 'none':
      default:
        // No background
        break;
    }

    // Add overlay if enabled
    if (backgroundConfig.useOverlay) {
      const overlay = document.createElement('div');
      overlay.className = 'bg-overlay';
      document.body.appendChild(overlay);
    }

    // Watch for theme changes to update background
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.attributeName === 'class') {
          const isDark = document.body.classList.contains('dark');

          // Update geometric/mesh backgrounds for dark mode
          if (backgroundConfig.type === 'geometric' || backgroundConfig.type === 'mesh') {
            if (isDark) {
              pageBg.classList.add('dark-mode');
            } else {
              pageBg.classList.remove('dark-mode');
            }
          }
        }
      });
    });

    observer.observe(document.body, { attributes: true });

    console.log('‚ú® Background configuration complete!');
  })();
</script>

{{/* Load external scripts for adaptive text */}}
<script src="/js/particle-background.js"></script>
<script src="/js/bio-fix.js"></script>
<script src="/js/adaptive-text-color.js"></script>

{{/* Optional: Add content overlay for better readability */}}
<style>
  /* Ensure page content is above background */
  .page-body {
    position: relative;
    z-index: 1;
  }

  /* Optional: Add subtle backdrop to improve readability */
  body::after {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(255, 255, 255, 0.7);
    z-index: 0;
    pointer-events: none;
    opacity: 0; /* Set to 1 to enable */
    transition: opacity 0.3s ease;
  }

  .dark body::after {
    background: rgba(15, 23, 42, 0.7);
  }

  /* Ensure header and footer are above overlay */
  .page-header,
  footer {
    position: relative;
    z-index: 10;
  }
</style>

{{/* Bio Markdown Renderer */}}
<script>
  /**
   * Bio Markdown Renderer
   * Converts markdown-style formatting in the bio text to proper HTML
   */
  (function() {
    'use strict';

    function renderBioMarkdown() {
      const bioContainer = document.querySelector('.bio-text');
      if (!bioContainer) {
        return;
      }

      // Get the HTML content (preserves newlines better than textContent)
      let content = bioContainer.innerHTML;

      // First, replace **text** with <strong>text</strong>
      content = content.replace(/\*\*([^\*]+)\*\*/g, '<strong>$1</strong>');

      // Split by newlines to create paragraphs
      const lines = content.split(/\n+/).map(line => line.trim()).filter(line => line.length > 0);

      // Group consecutive lines - each non-empty line becomes a paragraph
      const paragraphs = [];
      let currentPara = '';

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (line.length > 0) {
          if (currentPara.length > 0) {
            paragraphs.push(currentPara);
          }
          currentPara = line;
        }
      }

      // Add the last paragraph
      if (currentPara.length > 0) {
        paragraphs.push(currentPara);
      }

      // Create HTML for paragraphs
      const htmlParagraphs = paragraphs.map(para => {
        return `<p style="margin-bottom: 1.5rem; line-height: 1.75;">${para}</p>`;
      });

      // Replace the content
      bioContainer.innerHTML = htmlParagraphs.join('');

      // Add a class to indicate rendering is complete
      bioContainer.classList.add('bio-rendered');

      console.log(`‚úì Bio markdown rendered with ${paragraphs.length} paragraphs`);
    }

    // Run when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', renderBioMarkdown);
    } else {
      renderBioMarkdown();
    }
  })();
</script>
